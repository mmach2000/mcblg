---
title: 作为思维工具的符号系统
author: Kenneth E. Iverson
tags:
  - APL
  - 翻译
draft: true
mtime: '2024-09-16T14:30:42+08:00'
ctime: '2024-09-14T20:48:43+08:00'
---
import { Blockquote } from '@/components/react/Blockquote';
import '@/style/apl.css';

export const components = { blockquote: Blockquote };

:::tip[导读]
1979 年 10 月 29 日，在底特律举行的 ACM 年会上，
Kenneth E. Iverson 因其“在编程语言和数学符号方面的开创性努力（并作为结果产生了 APL）、
对交互式系统的实现、APL 的教育应用以及编程语言理论和实践的贡献”而获得了图灵奖。

本文是 Iverson 的图灵奖演讲，既凝缩了他对数学、编程语言和符号系统的思考，也是不可多得的 APL 语言教程。
:::

众所周知，命名体系、符号系统和语言都是承载思想的重要工具。
例如，拉瓦锡和林奈分别建立了化学领域和植物学领域的命名体系，二者都极大地激发和引导了后续的研究工作。
语言的意义同样深远：正如乔治 · 布尔在《思维规律的研究》中所言，
“语言不仅仅是表达思想的媒介，更是人类理性的工具，这一真理早已为世人所公认。”

种种语言中，数学符号无疑是最著名且最为成熟的思维工具，其在数学领域中的重要性不言而喻，
这一点在卡乔里《数学符号史》中由引述的数学家名言得以充分阐释。
这些名言值得仔细品读，以下两条摘录虽不足以囊括全貌，却已足以勾勒出其地位：

> 优良的数学符号减轻了大脑的额外负担，使其能够集中精力解决更为复杂的问题，从而有效地提升了人类的智力。
>
> —— 阿尔弗雷德 · 诺思 · 怀特海

> 代数符号将丰富的含义压缩于微小的空间内，因此我们习惯于借助这些符号进行推理。
>
> —— 查尔斯 · 巴比奇

尽管如此，数学符号作为思维工具仍有其不足之处。
数学符号不够统一：同一符号在不同主题、不同作者、甚至不同语境中都可能有不同的含义。
相比之下，编程语言作为指挥计算机的工具，具备了统一性、可执行性和无歧义性的显著优势。
可执行性使得我们能够借助计算机，对用编程语言表达的思想进行广泛而深入的实验；而无歧义性则使得精确的思维实验成为可能。
然而大多数编程语言在其他方面却明显不如数学符号，因此数学家很少将编程语言作为思维工具。

本文的核心论点在于，我们能够将编程语言和数学符号二者所长，融于一种统一而连贯的符号系统之中。
这种符号系统既继承了编程语言的统一性和可执行性，又兼具数学符号的种种优点。
下面分四节详细阐述这一论点：

1. 第一节将提炼数学符号系统的显著特点，并借助一系列简单的问题说明如何在一种可执行的语言中实现这些特点。

2. 第二、三节将继续使用这一符号系统探讨一些更深的主题。
第二节将探讨多项式的相关问题，而第三节将探讨函数的不同表示（包括全排列和有向图）之间的转换。
我们选择这些主题，主要是因为它们既实用，又有很多人感兴趣。
这些问题虽然属于数学范畴，却与计算机编程有着直接的联系。
随着编程科学逐渐发展为一门独立的数学学科，这种联系将变得越来越重要。

3. 第四节则展示了若干恒等式和形式证明的例子，其中许多形式证明是前几节非正式证明的形式化版本。

4. 最后一节将综合比较这种符号体系与传统数学符号系统的异同，并提供相关主题的参考资料，同时探讨在上下文中引入符号的相关问题。

本文所采用的“可执行语言”正是 APL。起初，这种记法并不是一门编程语言，而是一系列试图在书写和教学中引入准确而清晰的表述方式的尝试。
在多年的使用和发展后，APL 才被实现为一种编程语言。

尽管许多读者对 APL 并不熟悉，我还是决定不单独开设章节介绍 APL，而是在需要时在具体的上下文中逐步导入。
这就像数学课程中逐步介绍数学符号一样（与此相反，编程语言往往单独开设课程进行教学）。
我的观点是，好的思维工具应当能在相关的上下文中轻松介绍。
这种导入方法还有一个优点：读者可以评估 APL 各方面的相对难度。

然而，情境导入的方式并不能涵盖每种符号的全部细节。
之后若想使用本文所述的符号系统，读者需要有扩展符号定义或查阅参考资料的心理准备。
附录 A 总结了本文使用的所有符号，《APL 语言》第 24 至 60 页中也有详尽的阐述。

如果读者能接触到实现了 APL 的计算机，
可以使用附录 B 中给出的函数将本文用**直接定义形式**（direct definition form）给出的函数定义
（使用 `⍺` 和 `⍵` 来表示左右参数）转换为执行所需的**规范形式**（canonical form）[^no-need]。

[^no-need]: 译注：现如今 APL 实现（如 Dyalog APL 等）早已经支持直接定义形式，因此无需这种转换。

## 第一节 符号系统所需的显著特点

熟悉数学符号的人都能体会到数学符号系统的优点所在，
而我们的符号系统也应具备这些优点，同时兼备引言部分所述的统一性和可执行性。
我们在此列出数学符号系统的一些特点，以便引出后续讨论：

- 便于表述问题中产生的各种构造。
- 具有启发性。
- 能够有效地隐藏细节。
- 经济高效。
- 适合用于形式化证明。

讨论这些特点时，我们会时刻关注符号系统的可执行性和无歧义性。
为确保清晰无误，我们列出每个表达式的结果。
表达式有缩进，结果无缩进（就像 APL 机的输出一样）。
例如，**整数**函数 `⍳` 接收一个参数 `n` 时，会生成包含前 `n` 个整数的向量；
而**求和-归约** `+/` 接收一个向量作为参数，并给出向量中所有元素的和。
这二者表示如下：

```apl
      ⍳5
1 2 3 4 5
      +/⍳5
15
```

此外，我们还会使用一种不可执行的符号：`←→`，用以表示两个表达式之间的等价关系。

### 1. 便于表述问题中产生的各种构造

要使符号系统成为真正有效的思维工具，它不仅应当便于表达原问题中直接产生的构造，
还应能顺畅地表述在后续分析问题、泛化和特化问题中出现的各种构造。

以图 1 中所示的晶体结构为例，其中同一层的原子并非直接叠加在上一层的原子之上，而是“紧密堆积”在下层原子之间的空隙中。
因此，图 1 中从上往下各行的原子数目由 `⍳5` 表示，原子总数则由 `+/⍳5` 计算得出。

<figure>
  <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 17 18"
       mx-auto role="img" aria-labelledby="svg-crystal-title svg-crystal-desc">
    <title id="svg-crystal-title">晶体结构</title>
    <desc id="svg-crystal-desc">小圆圈组成的三角形，从上到下分别有 1、2、3、4、5 个小圆圈</desc>
    <g fill="none" stroke="var(--sl-color-text)" stroke-width=".3" transform="translate(-.14 .05)">
      <circle cx="8.6" cy=".9" r=".8"/>
      <circle cx="10.5" cy="4.9" r=".8"/>
      <circle cx="6.7" cy="4.9" r=".8"/>
      <circle cx="12.4" cy="8.8" r=".8"/>
      <circle cx="8.6" cy="8.8" r=".8"/>
      <circle cx="4.8" cy="8.8" r=".8"/>
      <circle cx="14.3" cy="12.8" r=".8"/>
      <circle cx="10.5" cy="12.8" r=".8"/>
      <circle cx="6.7" cy="12.8" r=".8"/>
      <circle cx="2.9" cy="12.8" r=".8"/>
      <circle cx="16.2" cy="16.8" r=".8"/>
      <circle cx="12.4" cy="16.8" r=".8"/>
      <circle cx="8.6" cy="16.8" r=".8"/>
      <circle cx="4.8" cy="16.8" r=".8"/>
      <circle cx=".9" cy="16.8" r=".8"/>
    </g>
  </svg>
  <figcaption text-center id="fig-crystal">
    图 1
  </figcaption>
</figure>

让我们继续考虑这种紧密堆积晶体的三维结构。
图 1 上方一层中的原子会堆积在图 1 原子的间隙上，形成一个底边有 4 个原子的三角形层。
可以想见，与图 1 对应的完整三维结构是一个四面体，各层底边的长度依次为 1、2、3、4、5。
因此，各层的原子数是向量 `⍳5` 的“部分和”，即第一个元素的总和、前两个元素的总和等。
我们将向量 `v` 的部分和向量记作 `+\v`，其中 `+\` 函数称为**求和-扫描**。
因此：

```apl
      +\⍳5
1 3 6 10 15
      +/+\⍳5
35
```

最终的表达式 `+/+\⍳5` 表达的就是四面体中原子的总数。

图 2 的左侧图形给出了表示 `+/⍳5` 的另一种方式，而右侧则是将左侧图形颠倒后形成的对称图案。
这种表示方式暗示了 `+/⍳5` 可能与矩形中单元的个数——也就是某种乘积——有关。

<figure>
  <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" version="1.1" viewBox="0 0 18 19.2"
       aria-label="⎕ ⎕⎕⎕⎕⎕ 换行 ⎕⎕ ⎕⎕⎕⎕ 换行 ⎕⎕⎕ ⎕⎕⎕ 换行 ⎕⎕⎕⎕ ⎕⎕ 换行 ⎕⎕⎕⎕⎕ ⎕" mx-auto role="img">
    <path transform="translate(-.13 .1)" fill="none" stroke="var(--sl-color-text)" stroke-width=".3"
          d="M-.23.1h1.4v2.6h-1.4zM9.3.1h1.4v2.6H9.3Zm1.9 0h1.4v2.6h-1.4zm1.91 0h1.4v2.6h-1.4zm1.9 0h1.4v2.6h-1.4zm1.91 0h1.4v2.6h-1.4zM-.23 4.07h1.4v2.6h-1.4zm1.91 0h1.4v2.6h-1.4zm9.52 0h1.4v2.6h-1.4zm1.91 0h1.4v2.6h-1.4zm1.9 0h1.4v2.6h-1.4zm1.91 0h1.4v2.6h-1.4zM-.23 8.04h1.4v2.6h-1.4zm1.91 0h1.4v2.6h-1.4zm1.9 0h1.4v2.6h-1.4zm9.53 0h1.4v2.6h-1.4zm1.9 0h1.4v2.6h-1.4zm1.91 0h1.4v2.6h-1.4zM-.23 12.01h1.4v2.6h-1.4zm1.91 0h1.4v2.6h-1.4zm1.9 0h1.4v2.6h-1.4zm1.91 0h1.4v2.6h-1.4zm9.52 0h1.4v2.6h-1.4zm1.91 0h1.4v2.6h-1.4zM-.23 15.98h1.4v2.6h-1.4zm1.91 0h1.4v2.6h-1.4zm1.9 0h1.4v2.6h-1.4zm1.91 0h1.4v2.6h-1.4zm1.9 0h1.4v2.6h-1.4zm9.53 0h1.4v2.6h-1.4z"/>
  </svg>
  <figcaption text-center id="fig-rect">
    图 2
  </figcaption>
</figure>

将两部分拼合在一起，各行长度的向量就等于向量 `⍳5` 与反转的 `⍳5` 之和。
确切地说：

```apl
      ⍳6
1 2 3 4 5 6
      ⍳5
1 2 3 4 5
      ⌽⍳5
5 4 3 2 1
      (⍳5)+(⌽⍳5)
6 6 6 6 6
```

我们使用 `5⍴6` 这种简洁的方式来表示 `6` 重复 5 次，因此：

```apl
      5⍴6
6 6 6 6 6
      +/5⍴6
30
      6×5
30
```

可以看出，`+/5⍴6 ←→ 6×5`，这一结果符合乘法作为加法重复的定义。

这些现象表明，`+/⍳5 ←→ (6×5)÷2`。更一般地，我们有：

<span id="eq:A.1"/>

```apl title="A.1"
      +/⍳n ←→ ((n+1)×n)÷2
```

### 2. 具有启发性

具有**启发性**的符号系统能够“举一反三”，从一个领域的表达式中引出其他相关的表达式，而这些表达式又能在其他问题中得到应用。
下面讨论我们目前用到的函数（即 `⍳`、`⌽`、`⍴`、`+/`、`+\`）之间的关联性。

举个例子：

```apl
      5⍴2
2 2 2 2 2
      ×/5⍴2
32
```

这个例子表明，`×/m⍴n ←→ n*m`，其中 `*` 表示幂函数。
这折射出幂函数（用乘法定义）与乘法（用加法定义）之间的相似性，这种相似性可以表示为：

```apl
      +/m⍴n ←→ n×m
      ×/m⍴n ←→ n*m
```

部分和与部分积之间也有这种相似性：

```apl
      ×\5⍴2
2 4 8 16 32
      2*⍳5
2 4 8 16 32
```

```apl
      +\m⍴n ←→ n×⍳m
      ×\m⍴n ←→ n*⍳m
```

第二个例子是几何数。
形如 `+\⍳5` 的部分和也叫**三角形数**，因为它们可以用图 1 中的三角形表示。
三角形数是**几何数**的一种特殊情况，其他几何数可以通过对 `+\⍳n` 或者 `+\n⍴1` 反复应用求和-扫描得到。
也就是：

```apl
      5⍴1
1 1 1 1 1
      +\5⍴1
1 2 3 4 5
      +\+\5⍴1
1 3 6 10 15
      +\+\+\5⍴1
1 4 10 20 35
```

将式子中的和换成积，我们得到的就是阶乘：

```apl
      ⍳5
1 2 3 4 5
      ×/⍳5
120
      !5
120
      !⍳5
1 2 6 24 120
```

具有启发性的符号系统使我们能够用简洁、通用且容易记忆的形式来表达恒等式。
我们将通过一个表达式来说明这一点，这个表达式说明了函数间的**对偶性**，涵盖了德-摩根定律、用对数求乘积以及其他不太常见的恒等式。

若 `v` 是整数组成的向量，则我们可以通过对数求出 `×/v`。
具体来说，我们可以通过 `⍟v` 求出 `v` 中每个元素的自然对数，通过 `+/⍟v` 将这些对数求和，最后通过 exp 函数 `*+/⍟v` 求出乘积。
换句话说：

```apl
      ×/v ←→ *+/⍟v
```

考虑到指数函数 `*` 是自然对数函数 `⍟` 的逆函数，我们可以将上述等式的右边推广为：

```apl
      ig f/g v
```

其中 `ig` 是 `g` 的逆函数。

用 `∧`、`∨`、`~` 来表示逻辑上的**与**、**或**、**非**，注意到逻辑非是自身的逆函数，
那么任意数量命题的德-摩根定律就可以表示为：

```apl
      ∧/b ←→ ~∨/~b
      ∨/b ←→ ~∧/~b
```

当然，此处向量 `b` 的元素被限制为布尔值 0 和 1。
再加上关系符号（这里，关系符号都是返回 0 或 1 的**函数**），我们就能表达更多的对偶性：

```apl
      ≠/b ←→ ~=/~b
      =/b ←→ ~≠/~b
```

最后，用 `⌈` 和 `⌊` 表示**最大值**和**最小值**函数，我们就可以表达算术取反的对偶性：

```apl
      ⌈/v ←→ -⌊/-v
      ⌊/v ←→ -⌈/-v
```

此外，上述所有的对偶性中，都可以用扫描 `f\` 替代归约 `f/`。

### 3. 有效地隐藏细节

正如前文引述的巴比奇所言，简洁性能极大地助力推理的过程。
实现简洁性的方法就是将细节摆在次要位置。
接下来我们将讨论 3 种隐藏细节的重要方法：使用数组、为函数和变量命名、使用算子。

前文已经展示了处理对偶性时一维数组（即向量）所带来的简洁性。
而矩阵和其他高维数组则进一步提供了简化的可能，
这是因为在向量上定义的函数可以系统地扩展到这些更高维数组上。

在应用函数时，我们可以指定函数作用于矩阵的哪一个轴，这一点在处理高维数组时尤为重要。
例如，`⌽[1]m` 作用于矩阵 `m` 的第一个轴，从而反转每一列；而 `⌽[2]m` 则会反转每一行；
`m,[1]n` 会将 `m` 和 `n` 的列连接在一起（将 `m` 放在 `n` 上面），`m,[2]n` 则连接将行连接在一起；
`+/[1]m` 对 `m` 的列进行求和，`+/[2]m` 对行进行求和。
如果没有指定轴，函数将沿最后一个轴进行操作。
因此，`+/m` 就是对 `m` 的行进行求和。
最后，沿**第一个轴**的归约和扫描操作可以用符号 `⌿` 和 `⍀` 来表示。

名字可以划分为两类：**固定名字**和**临时名字**（也叫**变量名字**）。
固定名字用于广泛使用的固定对象；
临时名字则用符号 `←` 指定，用于特定场景下我们感兴趣的量。
例如，下面代码中的 `144` 就是一个固定名字，而 `crate`、`layer` 和 `row` 则是临时名字：

```apl
      crate ← 144
      layer ← crate÷8
      row ← layer÷3
```

向量也有固定名字，例如 `2 3 5 7 11` 表示一个长度为 5 的数字向量，而 `'abode'` 则表示一个长度为 5 的字符向量。

这样的划分在函数上也成立。
用途广泛的**基本函数**，例如 `+`、`×` 和 `*`，都被赋予了固定名字。
而像 `+/m⍴n` 和 `*/mc` 之类的详细定义则依赖于 `×` 和 `*` 这样的固定名字。

我们的符号系统还有一些函数，这些函数相比而言不太常见，但同样拥有固定名字。
比如用于**连接**参数的逗号函数 `,`：

```apl
      (⍳5),(⌽⍳5) ←→ 1 2 3 4 5 5 4 3 2 1
```

再比如**进制表示**函数 `⊤`，它接收左参数作为（可变的）进位基数，右参数作为需要转换的数：

```apl
      2 2 2 ⊤ 3 ←→ 0 1 1
      2 2 2 ⊤ 4 ←→ 1 0 0
```

```apl
      bn←2 2 2 ⊤ 0 1 2 3 4 5 6 7
      bn
0 0 0 0 1 1 1 1
0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1

      bn,⌽bn
0 0 0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 0 0 1 1 1 1 0 0 1 1 0 0
0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0
```

矩阵 `bn` 值得关注，因为它有多种解读方式。
它的列除了能表示 0 到 7 的二进制数外，还能表示三元素集合的所有子集，以及三布尔值真值表的条目。
显而易见，`n` 元素的通用的表达式是 `(n⍴2)⊤(⍳2n)-1`，也许我们需要为这个函数赋予一个临时名字。
使用直接定义形式（见附录 B），我们可以将临时名字 `T` 赋给这个函数，如下所示：

```apl title="A.2"
      T:(⍵⍴2)⊤(⍳2*⍵)-1
```

其中 `⍵` 代表函数的参数。如果函数有两个参数，那么用 `⍺` 表示左参数，`⍵` 表示右参数。
定义函数 `T` 后，表达式 `T 3` 将得到上述的布尔矩阵 `bn`。

定义函数的另一种方式是使用冒号分隔的三个表达式。
中间的表达式最先执行；如果中间表达式的值为 0，则执行第一个表达式，否则执行最后一个表达式。
这种形式在定义递归函数时尤为便利。
例如，生成指定阶二项式系数的函数可以写作：

```apl title="A.3"
      bc:(x,0)+(0,x←bc ⍵-1):⍵=0:1
```

可以验证，`bc 0 ←→ 1`，`bc 1 ←→ 1 1`，`bc 4 ←→ 1 4 6 4 1`。

平时我们会将 operator（对应中文中的操作符）视作**函数**的同义词；
但在数学中 operator 有着更为严格的定义，指的是将函数映射到函数的实体（对应中文中的**算子**）。
一个典型的算子是导数算子 $\frac{\mathrm{d}}{\mathrm{d}x}$。

我们已经见过两种算子：**归约算子** `/` 和**扫描算子** `\`；
它们作用于不同的函数，得到了一系列相关的函数，如 `+/`、`×/` 和 `∧/`，这使得我们能够更简洁地表达问题。
这种由算子生成的函数称为**派生函数**。
现在我们将通过引入**内积算子**（用点号 `.` 表示）来进一步说明算子的概念。

若 `p` 和 `q` 是两个向量，则二者的内积 `+.×` 定义为：

```apl
      p+.×q ←→ +/p×q
```

类似的定义也适用于其他函数对：

```apl
      p←2 3 5
      q←2 1 2
      p+.×q
17
      p×.*q
300
      p⌊.+q
4
```

这些函数都至少有一种有用的含义：
`p+.×q` 是给定价格向量 `p` 和订单数量向量 `q` 时的总成本；
若 `p` 是质数向量，则 `q` 是 `p×.*q` 质因数分解中各项的指数；
若 `p` 表示源点到各中转点的距离，`q` 表示各中转点到目的地的距离，则 `p⌊.+q` 是原点到目的地的最短距离。

函数 `+.×` 相当于数学中的内积或点积。
和数学中一样，这个函数也可以扩展到矩阵上。
其他函数，如 `×.*`，也可以类似地扩展。
例如，如果 T 是由 [A.2](#A.2) 定义的函数，那么：

```apl
      T 3
0 0 0 0 1 1 1 1
0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1
      p+.×T 3
0 5 3 8 2 7 5 10
      p×.*T 3
1 5 3 15 2 10 6 30
```

这些例子引出了一个重要的特征：
若 `b` 是布尔向量，则 `p+.×b` 表示 `p` 的子集和，而 `p×.*b` 则表示 `p` 的子集积，
其中被求和或求乘积的子集由 `b` 中的 `1` 指定。

内积算子的另一种特殊用法是 `∘.×`，它将左参数的每个元素与右参数的每个元素相乘，例如：

```apl
      2 3 5∘.×⍳5
2 4 6 8 10
3 6 9 12 15
5 10 15 20 25
```

和张量分析中一样，这个函数称为**外积**；类似地，`∘.+`、`∘.*` 和 `∘.<` 都能生成特定函数的“函数表”：

```apl
      d←0 1 2 3
      d∘.⌈d
0 1 2 3
1 1 2 3
2 2 2 3
3 3 3 3

      d∘.≥d
1 0 0 0
1 1 0 0
1 1 1 0
1 1 1 1

      d∘.!d
1 1 1 1
0 1 2 3
0 0 1 3
0 0 0 1
```

其中，`!` 表示二项式系数函数。
可以看出，表 `d∘.!d` 实际上是帕斯卡三角形的一部分，左上角是顶点；
如果将其扩展到负参数（如 `d←¯3 ¯2 ¯1 0 1 2 3`），它还将包含三角形数等图形数。
这种负参数的扩展对其他函数也同样适用。
例如，表 `d∘.×d` 由四个象限组成，中间由一行 `0` 和一列 `0` 分隔，这四个象限清晰地展示了乘法的符号规则。

<details>
  <summary>
    负参数版本的函数表
  </summary>
```apl
      d←¯4 ¯3 ¯2 ¯1 0 1 2 3 4
      d∘.!d
  1  ¯3  3 ¯1 0 0 0 0 0
  0   1 ¯2  1 0 0 0 0 0
  0   0  1 ¯1 0 0 0 0 0
  0   0  0  1 0 0 0 0 0
  1   1  1  1 1 1 1 1 1
 ¯4  ¯3 ¯2 ¯1 0 1 2 3 4
 10   6  3  1 0 0 1 3 6
¯20 ¯10 ¯4 ¯1 0 0 0 1 4
 35  15  5  1 0 0 0 0 1
      d∘.×d
 16  12  8  4 0 ¯4 ¯8 ¯12 ¯16
 12   9  6  3 0 ¯3 ¯6  ¯9 ¯12
  8   6  4  2 0 ¯2 ¯4  ¯6  ¯8
  4   3  2  1 0 ¯1 ¯2  ¯3  ¯4
  0   0  0  0 0  0  0   0   0
 ¯4  ¯3 ¯2 ¯1 0  1  2   3   4
 ¯8  ¯6 ¯4 ¯2 0  2  4   6   8
¯12  ¯9 ¯6 ¯3 0  3  6   9  12
¯16 ¯12 ¯8 ¯4 0  4  8  12  16
```
</details>

观察这些函数表的特征，我们还能得到函数的其他信息，并通过穷举法简洁地证明函数的某些性质。
例如，交换律表现为函数表关于对角线的对称性：
若转置函数 `⍉`（用于反转参数的轴顺序）应用于表 `t←d∘.f d` 后得到的结果与 `t` 相同，
则说明函数 `f` 在定义域 `d` 上满足交换律。
例如，`t=⍉t←d∘.⌈d` 得到的是一个全部为 `1` 的表，因为 `⌈` 满足交换律。

测试结合律则需要形如 `d∘.f(d∘.f d)` 和 `(d∘.f d)∘.f d` 的三维矩阵：

```apl
      d←0 1
      d∘.∧(d∘.∧d)
0 0
0 0

0 0
0 1

      (d∘.∧d)∘.∧d
0 0
0 0

0 0
0 1

      d∘.≤(d∘.≤d)
1 1
1 1

1 1
0 1

      (d∘.≤d)∘.≤d
0 1
0 1

1 1
0 1
```
